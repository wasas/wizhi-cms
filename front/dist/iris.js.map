{"version":3,"sources":["../assets/scripts/forms/iris.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"iris.js","sourcesContent":["/*! Iris Color Picker - v1.0.7 - 2014-11-28\n* https://github.com/Automattic/Iris\n* Copyright (c) 2014 Matt Wiebe; Licensed GPLv2 */\n(function( $, undef ){\n\tvar _html, nonGradientIE, gradientType, vendorPrefixes, _css, Iris, UA, isIE, IEVersion;\n\n\t_html = '<div class=\"iris-picker\"><div class=\"iris-picker-inner\"><div class=\"iris-square\"><a class=\"iris-square-value\" href=\"#\"><span class=\"iris-square-handle ui-slider-handle\"></span></a><div class=\"iris-square-inner iris-square-horiz\"></div><div class=\"iris-square-inner iris-square-vert\"></div></div><div class=\"iris-slider iris-strip\"><div class=\"iris-slider-offset\"></div></div></div></div>';\n\t_css = '.iris-picker{display:block;position:relative}.iris-picker,.iris-picker *{-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input+.iris-picker{margin-top:4px}.iris-error{background-color:#ffafaf}.iris-border{border-radius:3px;border:1px solid #aaa;width:200px;background-color:#fff}.iris-picker-inner{position:absolute;top:0;right:0;left:0;bottom:0}.iris-border .iris-picker-inner{top:10px;right:10px;left:10px;bottom:10px}.iris-picker .iris-square-inner{position:absolute;left:0;right:0;top:0;bottom:0}.iris-picker .iris-square,.iris-picker .iris-slider,.iris-picker .iris-square-inner,.iris-picker .iris-palette{border-radius:3px;box-shadow:inset 0 0 5px rgba(0,0,0,.4);height:100%;width:12.5%;float:left;margin-right:5%}.iris-picker .iris-square{width:76%;margin-right:10%;position:relative}.iris-picker .iris-square-inner{width:auto;margin:0}.iris-ie-9 .iris-square,.iris-ie-9 .iris-slider,.iris-ie-9 .iris-square-inner,.iris-ie-9 .iris-palette{box-shadow:none;border-radius:0}.iris-ie-9 .iris-square,.iris-ie-9 .iris-slider,.iris-ie-9 .iris-palette{outline:1px solid rgba(0,0,0,.1)}.iris-ie-lt9 .iris-square,.iris-ie-lt9 .iris-slider,.iris-ie-lt9 .iris-square-inner,.iris-ie-lt9 .iris-palette{outline:1px solid #aaa}.iris-ie-lt9 .iris-square .ui-slider-handle{outline:1px solid #aaa;background-color:#fff;-ms-filter:\"alpha(Opacity=30)\"}.iris-ie-lt9 .iris-square .iris-square-handle{background:0;border:3px solid #fff;-ms-filter:\"alpha(Opacity=50)\"}.iris-picker .iris-strip{margin-right:0;position:relative}.iris-picker .iris-strip .ui-slider-handle{position:absolute;background:0;margin:0;right:-3px;left:-3px;border:4px solid #aaa;border-width:4px 3px;width:auto;height:6px;border-radius:4px;box-shadow:0 1px 2px rgba(0,0,0,.2);opacity:.9;z-index:5;cursor:ns-resize}.iris-strip .ui-slider-handle:before{content:\" \";position:absolute;left:-2px;right:-2px;top:-3px;bottom:-3px;border:2px solid #fff;border-radius:3px}.iris-picker .iris-slider-offset{position:absolute;top:11px;left:0;right:0;bottom:-3px;width:auto;height:auto;background:transparent;border:0;border-radius:0}.iris-picker .iris-square-handle{background:transparent;border:5px solid #aaa;border-radius:50%;border-color:rgba(128,128,128,.5);box-shadow:none;width:12px;height:12px;position:absolute;left:-10px;top:-10px;cursor:move;opacity:1;z-index:10}.iris-picker .ui-state-focus .iris-square-handle{opacity:.8}.iris-picker .iris-square-handle:hover{border-color:#999}.iris-picker .iris-square-value:focus .iris-square-handle{box-shadow:0 0 2px rgba(0,0,0,.75);opacity:.8}.iris-picker .iris-square-handle:hover::after{border-color:#fff}.iris-picker .iris-square-handle::after{position:absolute;bottom:-4px;right:-4px;left:-4px;top:-4px;border:3px solid #f9f9f9;border-color:rgba(255,255,255,.8);border-radius:50%;content:\" \"}.iris-picker .iris-square-value{width:8px;height:8px;position:absolute}.iris-ie-lt9 .iris-square-value,.iris-mozilla .iris-square-value{width:1px;height:1px}.iris-palette-container{position:absolute;bottom:0;left:0;margin:0;padding:0}.iris-border .iris-palette-container{left:10px;bottom:10px}.iris-picker .iris-palette{margin:0;cursor:pointer}.iris-square-handle,.ui-slider-handle{border:0;outline:0}';\n\n\t// Even IE9 dosen't support gradients. Elaborate sigh.\n\tUA = navigator.userAgent.toLowerCase();\n\tisIE = navigator.appName === 'Microsoft Internet Explorer';\n\tIEVersion = isIE ? parseFloat( UA.match( /msie ([0-9]{1,}[\\.0-9]{0,})/ )[1] ) : 0;\n\tnonGradientIE = ( isIE && IEVersion < 10 );\n\tgradientType = false;\n\n\t// we don't bother with an unprefixed version, as it has a different syntax\n\tvendorPrefixes = [ '-moz-', '-webkit-', '-o-', '-ms-' ];\n\n\t// Bail for IE <= 7\n\tif ( nonGradientIE && IEVersion <= 7 ) {\n\t\t$.fn.iris = $.noop;\n\t\t$.support.iris = false;\n\t\treturn;\n\t}\n\n\t$.support.iris = true;\n\n\tfunction testGradientType() {\n\t\tvar el, base,\n\t\t\tbgImageString = 'backgroundImage';\n\n\t\tif ( nonGradientIE ) {\n\t\t\tgradientType = 'filter';\n\t\t}\n\t\telse {\n\t\t\tel = $( '<div id=\"iris-gradtest\" />' );\n\t\t\tbase = 'linear-gradient(top,#fff,#000)';\n\t\t\t$.each( vendorPrefixes, function( i, val ){\n\t\t\t\tel.css( bgImageString, val + base );\n\t\t\t\tif ( el.css( bgImageString ).match( 'gradient' ) ) {\n\t\t\t\t\tgradientType = i;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// check for legacy webkit gradient syntax\n\t\t\tif ( gradientType === false ) {\n\t\t\t\tel.css( 'background', '-webkit-gradient(linear,0% 0%,0% 100%,from(#fff),to(#000))' );\n\t\t\t\tif ( el.css( bgImageString ).match( 'gradient' ) ) {\n\t\t\t\t\tgradientType = 'webkit';\n\t\t\t\t}\n\t\t\t}\n\t\t\tel.remove();\n\t\t}\n\n\t}\n\n\t/**\n\t* Only for CSS3 gradients. oldIE will use a separate function.\n\t*\n\t* Accepts as many color stops as necessary from 2nd arg on, or 2nd\n\t* arg can be an array of color stops\n\t*\n\t* @param  {string} origin Gradient origin - top or left, defaults to left.\n\t* @return {string}        Appropriate CSS3 gradient string for use in\n\t*/\n\tfunction createGradient( origin, stops ) {\n\t\torigin = ( origin === 'top' ) ? 'top' : 'left';\n\t\tstops = $.isArray( stops ) ? stops : Array.prototype.slice.call( arguments, 1 );\n\t\tif ( gradientType === 'webkit' ) {\n\t\t\treturn legacyWebkitGradient( origin, stops );\n\t\t} else {\n\t\t\treturn vendorPrefixes[ gradientType ] + 'linear-gradient(' + origin + ', ' + stops.join(', ') + ')';\n\t\t}\n\t}\n\n\t/**\n\t* Stupid gradients for a stupid browser.\n\t*/\n\tfunction stupidIEGradient( origin, stops ) {\n\t\tvar type, self, lastIndex, filter, startPosProp, endPosProp, dimensionProp, template, html;\n\n\t\torigin = ( origin === 'top' ) ? 'top' : 'left';\n\t\tstops = $.isArray( stops ) ? stops : Array.prototype.slice.call( arguments, 1 );\n\t\t// 8 hex: AARRGGBB\n\t\t// GradientType: 0 vertical, 1 horizontal\n\t\ttype = ( origin === 'top' ) ? 0 : 1;\n\t\tself = $( this );\n\t\tlastIndex = stops.length - 1;\n\t\tfilter = 'filter';\n\t\tstartPosProp = ( type === 1 ) ? 'left' : 'top';\n\t\tendPosProp = ( type === 1 ) ? 'right' : 'bottom';\n\t\tdimensionProp = ( type === 1 ) ? 'height' : 'width';\n\t\ttemplate = '<div class=\"iris-ie-gradient-shim\" style=\"position:absolute;' + dimensionProp + ':100%;' + startPosProp + ':%start%;' + endPosProp + ':%end%;' + filter + ':%filter%;\" data-color:\"%color%\"></div>';\n\t\thtml = '';\n\t\t// need a positioning context\n\t\tif ( self.css('position') === 'static' ) {\n\t\t\tself.css( {position: 'relative' } );\n\t\t}\n\n\t\tstops = fillColorStops( stops );\n\t\t$.each(stops, function( i, startColor ) {\n\t\t\tvar endColor, endStop, filterVal;\n\n\t\t\t// we want two at a time. if we're on the last pair, bail.\n\t\t\tif ( i === lastIndex ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tendColor = stops[ i + 1 ];\n\t\t\t//if our pairs are at the same color stop, moving along.\n\t\t\tif ( startColor.stop === endColor.stop ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tendStop = 100 - parseFloat( endColor.stop ) + '%';\n\t\t\tstartColor.octoHex = new Color( startColor.color ).toIEOctoHex();\n\t\t\tendColor.octoHex = new Color( endColor.color ).toIEOctoHex();\n\n\t\t\tfilterVal = 'progid:DXImageTransform.Microsoft.Gradient(GradientType=' + type + ', StartColorStr=\\'' + startColor.octoHex + '\\', EndColorStr=\\'' + endColor.octoHex + '\\')';\n\t\t\thtml += template.replace( '%start%', startColor.stop ).replace( '%end%', endStop ).replace( '%filter%', filterVal );\n\t\t});\n\t\tself.find( '.iris-ie-gradient-shim' ).remove();\n\t\t$( html ).prependTo( self );\n\t}\n\n\tfunction legacyWebkitGradient( origin, colorList ) {\n\t\tvar stops = [];\n\t\torigin = ( origin === 'top' ) ? '0% 0%,0% 100%,' : '0% 100%,100% 100%,';\n\t\tcolorList = fillColorStops( colorList );\n\t\t$.each( colorList, function( i, val ){\n\t\t\tstops.push( 'color-stop(' + ( parseFloat( val.stop ) / 100 ) + ', ' + val.color + ')' );\n\t\t});\n\t\treturn '-webkit-gradient(linear,' + origin + stops.join(',') + ')';\n\t}\n\n\tfunction fillColorStops( colorList ) {\n\t\tvar colors = [],\n\t\t\tpercs = [],\n\t\t\tnewColorList = [],\n\t\t\tlastIndex = colorList.length - 1;\n\n\t\t$.each( colorList, function( index, val ) {\n\t\t\tvar color = val,\n\t\t\t\tperc = false,\n\t\t\t\tmatch = val.match( /1?[0-9]{1,2}%$/ );\n\n\t\t\tif ( match ) {\n\t\t\t\tcolor = val.replace( /\\s?1?[0-9]{1,2}%$/, '' );\n\t\t\t\tperc = match.shift();\n\t\t\t}\n\t\t\tcolors.push( color );\n\t\t\tpercs.push( perc );\n\t\t});\n\n\t\t// back fill first and last\n\t\tif ( percs[0] === false ) {\n\t\t\tpercs[0] = '0%';\n\t\t}\n\n\t\tif ( percs[lastIndex] === false ) {\n\t\t\tpercs[lastIndex] = '100%';\n\t\t}\n\n\t\tpercs = backFillColorStops( percs );\n\n\t\t$.each( percs, function( i ){\n\t\t\tnewColorList[i] = { color: colors[i], stop: percs[i] };\n\t\t});\n\t\treturn newColorList;\n\t}\n\n\tfunction backFillColorStops( stops ) {\n\t\tvar first = 0,\n\t\t\tlast = stops.length - 1,\n\t\t\ti = 0,\n\t\t\tfoundFirst = false,\n\t\t\tincr,\n\t\t\tsteps,\n\t\t\tstep,\n\t\t\tfirstVal;\n\n\t\tif ( stops.length <= 2 || $.inArray( false, stops ) < 0 ) {\n\t\t\treturn stops;\n\t\t}\n\t\twhile ( i < stops.length - 1 ) {\n\t\t\tif ( ! foundFirst && stops[i] === false ) {\n\t\t\t\tfirst = i - 1;\n\t\t\t\tfoundFirst = true;\n\t\t\t} else if ( foundFirst && stops[i] !== false ) {\n\t\t\t\tlast = i;\n\t\t\t\ti = stops.length;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tsteps = last - first;\n\t\tfirstVal = parseInt( stops[first].replace('%'), 10 );\n\t\tincr = ( parseFloat( stops[last].replace('%') ) - firstVal ) / steps;\n\t\ti = first + 1;\n\t\tstep = 1;\n\t\twhile ( i < last ) {\n\t\t\tstops[i] = ( firstVal + ( step * incr ) ) + '%';\n\t\t\tstep++;\n\t\t\ti++;\n\t\t}\n\t\treturn backFillColorStops( stops );\n\t}\n\n\t$.fn.gradient = function() {\n\t\tvar args = arguments;\n\t\treturn this.each( function() {\n\t\t\t// this'll be oldishIE\n\t\t\tif ( nonGradientIE ) {\n\t\t\t\tstupidIEGradient.apply( this, args );\n\t\t\t} else {\n\t\t\t\t// new hotness\n\t\t\t\t$( this ).css( 'backgroundImage', createGradient.apply( this, args ) );\n\t\t\t}\n\t\t});\n\t};\n\n\t$.fn.raninbowGradient = function( origin, args ) {\n\t\tvar opts, template, i, steps;\n\n\t\torigin = origin || 'top';\n\t\topts = $.extend( {}, { s: 100, l: 50 }, args );\n\t\ttemplate = 'hsl(%h%,' + opts.s + '%,' + opts.l + '%)';\n\t\ti = 0;\n\t\tsteps = [];\n\t\twhile ( i <= 360 ) {\n\t\t\tsteps.push( template.replace('%h%', i) );\n\t\t\ti += 30;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\t$(this).gradient( origin, steps );\n\t\t});\n\t};\n\n\t// the colorpicker widget def.\n\tIris = {\n\t\toptions: {\n\t\t\tcolor: false,\n\t\t\tmode: 'hsl',\n\t\t\tcontrols: {\n\t\t\t\thoriz: 's', // horizontal defaults to saturation\n\t\t\t\tvert: 'l', // vertical defaults to lightness\n\t\t\t\tstrip: 'h' // right strip defaults to hue\n\t\t\t},\n\t\t\thide: true, // hide the color picker by default\n\t\t\tborder: true, // draw a border around the collection of UI elements\n\t\t\ttarget: false, // a DOM element / jQuery selector that the element will be appended within. Only used when called on an input.\n\t\t\twidth: 200, // the width of the collection of UI elements\n\t\t\tpalettes: false // show a palette of basic colors beneath the square.\n\t\t},\n\t\t_color: '',\n\t\t_palettes: [ '#000', '#fff', '#d33', '#d93', '#ee2', '#81d742', '#1e73be', '#8224e3' ],\n\t\t_inited: false,\n\t\t_defaultHSLControls: {\n\t\t\thoriz: 's',\n\t\t\tvert: 'l',\n\t\t\tstrip: 'h'\n\t\t},\n\t\t_defaultHSVControls: {\n\t\t\thoriz: 'h',\n\t\t\tvert: 'v',\n\t\t\tstrip: 's'\n\t\t},\n\t\t_scale: {\n\t\t\th: 360,\n\t\t\ts: 100,\n\t\t\tl: 100,\n\t\t\tv: 100\n\t\t},\n\t\t_create: function() {\n\t\t\tvar self = this,\n\t\t\t\tel = self.element,\n\t\t\t\tcolor = self.options.color || el.val();\n\n\t\t\tif ( gradientType === false ) {\n\t\t\t\ttestGradientType();\n\t\t\t}\n\n\t\t\tif ( el.is( 'input' ) ) {\n\t\t\t\tif ( self.options.target ) {\n\t\t\t\t\tself.picker = $( _html ).appendTo( self.options.target );\n\t\t\t\t} else {\n\t\t\t\t\tself.picker = $( _html ).insertAfter( el );\n\t\t\t\t}\n\n\t\t\t\tself._addInputListeners( el );\n\t\t\t} else {\n\t\t\t\tel.append( _html );\n\t\t\t\tself.picker = el.find( '.iris-picker' );\n\t\t\t}\n\n\t\t\t// Browsers / Versions\n\t\t\t// Feature detection doesn't work for these, and $.browser is deprecated\n\t\t\tif ( isIE ) {\n\t\t\t\tif ( IEVersion === 9 ) {\n\t\t\t\t\tself.picker.addClass( 'iris-ie-9' );\n\t\t\t\t} else if ( IEVersion <= 8 ) {\n\t\t\t\t\tself.picker.addClass( 'iris-ie-lt9' );\n\t\t\t\t}\n\t\t\t} else if ( UA.indexOf('compatible') < 0 && UA.indexOf('khtml') < 0 && UA.match( /mozilla/ ) ) {\n\t\t\t\tself.picker.addClass( 'iris-mozilla' );\n\t\t\t}\n\n\t\t\tif ( self.options.palettes ) {\n\t\t\t\tself._addPalettes();\n\t\t\t}\n\n\t\t\tself._color = new Color( color ).setHSpace( self.options.mode );\n\t\t\tself.options.color = self._color.toString();\n\n\t\t\t// prep 'em for re-use\n\t\t\tself.controls = {\n\t\t\t\tsquare:      self.picker.find( '.iris-square' ),\n\t\t\t\tsquareDrag:  self.picker.find( '.iris-square-value' ),\n\t\t\t\thoriz:       self.picker.find( '.iris-square-horiz' ),\n\t\t\t\tvert:        self.picker.find( '.iris-square-vert' ),\n\t\t\t\tstrip:       self.picker.find( '.iris-strip' ),\n\t\t\t\tstripSlider: self.picker.find( '.iris-strip .iris-slider-offset' )\n\t\t\t};\n\n\t\t\t// small sanity check - if we chose hsv, change default controls away from hsl\n\t\t\tif ( self.options.mode === 'hsv' && self._has('l', self.options.controls) ) {\n\t\t\t\tself.options.controls = self._defaultHSVControls;\n\t\t\t} else if ( self.options.mode === 'hsl' && self._has('v', self.options.controls) ) {\n\t\t\t\tself.options.controls = self._defaultHSLControls;\n\t\t\t}\n\n\t\t\t// store it. HSL gets squirrely\n\t\t\tself.hue = self._color.h();\n\n\t\t\tif ( self.options.hide ) {\n\t\t\t\tself.picker.hide();\n\t\t\t}\n\n\t\t\tif ( self.options.border ) {\n\t\t\t\tself.picker.addClass( 'iris-border' );\n\t\t\t}\n\n\t\t\tself._initControls();\n\t\t\tself.active = 'external';\n\t\t\tself._dimensions();\n\t\t\tself._change();\n\t\t},\n\t\t_has: function(needle, haystack) {\n\t\t\tvar ret = false;\n\t\t\t$.each(haystack, function(i,v){\n\t\t\t\tif ( needle === v ) {\n\t\t\t\t\tret = true;\n\t\t\t\t\t// exit the loop\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ret;\n\t\t},\n\t\t_addPalettes: function () {\n\t\t\tvar container = $( '<div class=\"iris-palette-container\" />' ),\n\t\t\t\tpalette = $( '<a class=\"iris-palette\" tabindex=\"0\" />' ),\n\t\t\t\tcolors = $.isArray( this.options.palettes ) ? this.options.palettes : this._palettes;\n\n\t\t\t// do we have an existing container? Empty and reuse it.\n\t\t\tif ( this.picker.find( '.iris-palette-container' ).length ) {\n\t\t\t\tcontainer = this.picker.find( '.iris-palette-container' ).detach().html( '' );\n\t\t\t}\n\n\t\t\t$.each(colors, function(index, val) {\n\t\t\t\tpalette.clone().data( 'color', val )\n\t\t\t\t\t.css( 'backgroundColor', val ).appendTo( container )\n\t\t\t\t\t.height( 10 ).width( 10 );\n\t\t\t});\n\n\t\t\tthis.picker.append(container);\n\t\t},\n\t\t_paint: function() {\n\t\t\tvar self = this;\n\t\t\tself._paintDimension( 'top', 'strip' );\n\t\t\tself._paintDimension( 'top', 'vert' );\n\t\t\tself._paintDimension( 'left', 'horiz' );\n\t\t},\n\t\t_paintDimension: function( origin, control ) {\n\t\t\tvar self = this,\n\t\t\t\tc = self._color,\n\t\t\t\tmode = self.options.mode,\n\t\t\t\tcolor = self._getHSpaceColor(),\n\t\t\t\ttarget = self.controls[ control ],\n\t\t\t\tcontrolOpts = self.options.controls,\n\t\t\t\tstops;\n\n\t\t\t// don't paint the active control\n\t\t\tif ( control === self.active || ( self.active === 'square' && control !== 'strip' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch ( controlOpts[ control ] ) {\n\t\t\t\tcase 'h':\n\t\t\t\t\tif ( mode === 'hsv' ) {\n\t\t\t\t\t\tcolor = c.clone();\n\t\t\t\t\t\tswitch ( control ) {\n\t\t\t\t\t\t\tcase 'horiz':\n\t\t\t\t\t\t\t\tcolor[controlOpts.vert](100);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vert':\n\t\t\t\t\t\t\t\tcolor[controlOpts.horiz](100);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'strip':\n\t\t\t\t\t\t\t\tcolor.setHSpace('hsl');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstops = color.toHsl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( control === 'strip' ) {\n\t\t\t\t\t\t\tstops = { s: color.s, l: color.l };\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstops = { s: 100, l: color.l };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget.raninbowGradient( origin, stops );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tif ( mode === 'hsv' ) {\n\t\t\t\t\t\tif ( control === 'vert' ) {\n\t\t\t\t\t\t\tstops = [ c.clone().a(0).s(0).toCSS('rgba'), c.clone().a(1).s(0).toCSS('rgba') ];\n\t\t\t\t\t\t} else if ( control === 'strip' ) {\n\t\t\t\t\t\t\tstops = [ c.clone().s(100).toCSS('hsl'), c.clone().s(0).toCSS('hsl') ];\n\t\t\t\t\t\t} else if ( control === 'horiz' ) {\n\t\t\t\t\t\t\tstops = [ '#fff', 'hsl(' + color.h + ',100%,50%)' ];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // implicit mode === 'hsl'\n\t\t\t\t\t\tif ( control === 'vert' && self.options.controls.horiz === 'h' ) {\n\t\t\t\t\t\t\tstops = ['hsla(0, 0%, ' + color.l + '%, 0)', 'hsla(0, 0%, ' + color.l + '%, 1)'];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstops = ['hsl('+ color.h +',0%,50%)', 'hsl(' + color.h + ',100%,50%)'];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\ttarget.gradient( origin, stops );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\tif ( control === 'strip' ) {\n\t\t\t\t\t\tstops = ['hsl(' + color.h + ',100%,100%)', 'hsl(' + color.h + ', ' + color.s + '%,50%)', 'hsl('+ color.h +',100%,0%)'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstops = ['#fff', 'rgba(255,255,255,0) 50%', 'rgba(0,0,0,0) 50%', 'rgba(0,0,0,1)'];\n\t\t\t\t\t}\n\t\t\t\t\ttarget.gradient( origin, stops );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\t\tif ( control === 'strip' ) {\n\t\t\t\t\t\t\tstops = [ c.clone().v(100).toCSS(), c.clone().v(0).toCSS() ];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstops = ['rgba(0,0,0,0)', '#000'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttarget.gradient( origin, stops );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\t\t_getHSpaceColor: function() {\n\t\t\treturn ( this.options.mode === 'hsv' ) ? this._color.toHsv() : this._color.toHsl();\n\t\t},\n\n\t\t_dimensions: function( reset ) {\n\t\t\t// whatever size\n\t\t\tvar self = this,\n\t\t\t\topts = self.options,\n\t\t\t\tcontrols = self.controls,\n\t\t\t\tsquare = controls.square,\n\t\t\t\tstrip = self.picker.find( '.iris-strip' ),\n\t\t\t\tsquareWidth = '77.5%',\n\t\t\t\tstripWidth = '12%',\n\t\t\t\ttotalPadding = 20,\n\t\t\t\tinnerWidth = opts.border ? opts.width - totalPadding : opts.width,\n\t\t\t\tcontrolsHeight,\n\t\t\t\tpaletteCount = $.isArray( opts.palettes ) ? opts.palettes.length : self._palettes.length,\n\t\t\t\tpaletteMargin, paletteWidth, paletteContainerWidth;\n\n\t\t\tif ( reset ) {\n\t\t\t\tsquare.css( 'width', '' );\n\t\t\t\tstrip.css( 'width', '' );\n\t\t\t\tself.picker.css( {width: '', height: ''} );\n\t\t\t}\n\n\t\t\tsquareWidth = innerWidth * ( parseFloat( squareWidth ) / 100 );\n\t\t\tstripWidth = innerWidth * ( parseFloat( stripWidth ) / 100 );\n\t\t\tcontrolsHeight = opts.border ? squareWidth + totalPadding : squareWidth;\n\n\t\t\tsquare.width( squareWidth ).height( squareWidth );\n\t\t\tstrip.height( squareWidth ).width( stripWidth );\n\t\t\tself.picker.css( { width: opts.width, height: controlsHeight } );\n\n\t\t\tif ( ! opts.palettes ) {\n\t\t\t\treturn self.picker.css( 'paddingBottom', '' );\n\t\t\t}\n\n\t\t\t// single margin at 2%\n\t\t\tpaletteMargin = squareWidth * 2 / 100;\n\t\t\tpaletteContainerWidth = squareWidth - ( ( paletteCount - 1 ) * paletteMargin );\n\t\t\tpaletteWidth = paletteContainerWidth / paletteCount;\n\t\t\tself.picker.find('.iris-palette').each( function( i ) {\n\t\t\t\tvar margin = i === 0 ? 0 : paletteMargin;\n\t\t\t\t$( this ).css({\n\t\t\t\t\twidth: paletteWidth,\n\t\t\t\t\theight: paletteWidth,\n\t\t\t\t\tmarginLeft: margin\n\t\t\t\t});\n\t\t\t});\n\t\t\tself.picker.css( 'paddingBottom', paletteWidth + paletteMargin );\n\t\t\tstrip.height( paletteWidth + paletteMargin + squareWidth );\n\t\t},\n\n\t\t_addInputListeners: function( input ) {\n\t\t\tvar self = this,\n\t\t\t\tdebounceTimeout = 100,\n\t\t\t\tcallback = function( event ){\n\t\t\t\t\tvar color = new Color( input.val() ),\n\t\t\t\t\t\tval = input.val().replace( /^#/, '' );\n\n\t\t\t\t\tinput.removeClass( 'iris-error' );\n\t\t\t\t\t// we gave a bad color\n\t\t\t\t\tif ( color.error ) {\n\t\t\t\t\t\t// don't error on an empty input - we want those allowed\n\t\t\t\t\t\tif ( val !== '' ) {\n\t\t\t\t\t\t\tinput.addClass( 'iris-error' );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( color.toString() !== self._color.toString() ) {\n\t\t\t\t\t\t\t// let's not do this on keyup for hex shortcodes\n\t\t\t\t\t\t\tif ( ! ( event.type === 'keyup' && val.match( /^[0-9a-fA-F]{3}$/ ) ) ) {\n\t\t\t\t\t\t\t\tself._setOption( 'color', color.toString() );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tinput.on( 'change', callback ).on( 'keyup', self._debounce( callback, debounceTimeout ) );\n\n\t\t\t// If we initialized hidden, show on first focus. The rest is up to you.\n\t\t\tif ( self.options.hide ) {\n\t\t\t\tinput.one( 'focus', function() {\n\t\t\t\t\tself.show();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t_initControls: function() {\n\t\t\tvar self = this,\n\t\t\t\tcontrols = self.controls,\n\t\t\t\tsquare = controls.square,\n\t\t\t\tcontrolOpts = self.options.controls,\n\t\t\t\tstripScale = self._scale[controlOpts.strip];\n\n\t\t\tcontrols.stripSlider.slider({\n\t\t\t\torientation: 'vertical',\n\t\t\t\tmax: stripScale,\n\t\t\t\tslide: function( event, ui ) {\n\t\t\t\t\tself.active = 'strip';\n\t\t\t\t\t// \"reverse\" for hue.\n\t\t\t\t\tif ( controlOpts.strip === 'h' ) {\n\t\t\t\t\t\tui.value = stripScale - ui.value;\n\t\t\t\t\t}\n\n\t\t\t\t\tself._color[controlOpts.strip]( ui.value );\n\t\t\t\t\tself._change.apply( self, arguments );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcontrols.squareDrag.draggable({\n\t\t\t\tcontainment: controls.square.find( '.iris-square-inner' ),\n\t\t\t\tzIndex: 1000,\n\t\t\t\tcursor: 'move',\n\t\t\t\tdrag: function( event, ui ) {\n\t\t\t\t\tself._squareDrag( event, ui );\n\t\t\t\t},\n\t\t\t\tstart: function() {\n\t\t\t\t\tsquare.addClass( 'iris-dragging' );\n\t\t\t\t\t$(this).addClass( 'ui-state-focus' );\n\t\t\t\t},\n\t\t\t\tstop: function() {\n\t\t\t\t\tsquare.removeClass( 'iris-dragging' );\n\t\t\t\t\t$(this).removeClass( 'ui-state-focus' );\n\t\t\t\t}\n\t\t\t}).on( 'mousedown mouseup', function( event ) {\n\t\t\t\tvar focusClass = 'ui-state-focus';\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif (event.type === 'mousedown' ) {\n\t\t\t\t\tself.picker.find( '.' + focusClass ).removeClass( focusClass ).blur();\n\t\t\t\t\t$(this).addClass( focusClass ).focus();\n\t\t\t\t} else {\n\t\t\t\t\t$(this).removeClass( focusClass );\n\t\t\t\t}\n\t\t\t}).on( 'keydown', function( event ) {\n\t\t\t\tvar container = controls.square,\n\t\t\t\t\tdraggable = controls.squareDrag,\n\t\t\t\t\tposition = draggable.position(),\n\t\t\t\t\tdistance = self.options.width / 100; // Distance in pixels the draggable should be moved: 1 \"stop\"\n\n\t\t\t\t// make alt key go \"10\"\n\t\t\t\tif ( event.altKey ) {\n\t\t\t\t\tdistance *= 10;\n\t\t\t\t}\n\n\t\t\t\t// Reposition if one of the directional keys is pressed\n\t\t\t\tswitch ( event.keyCode ) {\n\t\t\t\t\tcase 37: position.left -= distance; break; // Left\n\t\t\t\t\tcase 38: position.top  -= distance; break; // Up\n\t\t\t\t\tcase 39: position.left += distance; break; // Right\n\t\t\t\t\tcase 40: position.top  += distance; break; // Down\n\t\t\t\t\tdefault: return true; // Exit and bubble\n\t\t\t\t}\n\n\t\t\t\t// Keep draggable within container\n\t\t\t\tposition.left = Math.max( 0, Math.min( position.left, container.width() ) );\n\t\t\t\tposition.top =  Math.max( 0, Math.min( position.top, container.height() ) );\n\n\t\t\t\tdraggable.css(position);\n\t\t\t\tself._squareDrag( event, { position: position });\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\n\t\t\t// allow clicking on the square to move there and keep dragging\n\t\t\tsquare.mousedown( function( event ) {\n\t\t\t\tvar squareOffset, pos;\n\t\t\t\t// only left click\n\t\t\t\tif ( event.which !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// prevent bubbling from the handle: no infinite loops\n\t\t\t\tif ( ! $( event.target ).is( 'div' ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsquareOffset = self.controls.square.offset();\n\t\t\t\tpos = {\n\t\t\t\t\t\ttop: event.pageY - squareOffset.top,\n\t\t\t\t\t\tleft: event.pageX - squareOffset.left\n\t\t\t\t};\n\t\t\t\tevent.preventDefault();\n\t\t\t\tself._squareDrag( event, { position: pos } );\n\t\t\t\tevent.target = self.controls.squareDrag.get(0);\n\t\t\t\tself.controls.squareDrag.css( pos ).trigger( event );\n\t\t\t});\n\n\t\t\t// palettes\n\t\t\tif ( self.options.palettes ) {\n\t\t\t\tself._paletteListeners();\n\t\t\t}\n\t\t},\n\n\t\t_paletteListeners: function() {\n\t\t\tvar self = this;\n\t\t\tself.picker.find('.iris-palette-container').on('click.palette', '.iris-palette', function() {\n\t\t\t\tself._color.fromCSS( $(this).data('color') );\n\t\t\t\tself.active = 'external';\n\t\t\t\tself._change();\n\t\t\t}).on( 'keydown.palette', '.iris-palette', function( event ) {\n\t\t\t\tif ( ! ( event.keyCode === 13 || event.keyCode === 32 ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t$( this ).click();\n\t\t\t});\n\t\t},\n\n\t\t_squareDrag: function( event, ui ) {\n\t\t\tvar self = this,\n\t\t\t\tcontrolOpts = self.options.controls,\n\t\t\t\tdimensions = self._squareDimensions(),\n\t\t\t\tvertVal = Math.round( ( dimensions.h - ui.position.top ) / dimensions.h * self._scale[controlOpts.vert] ),\n\t\t\t\thorizVal = self._scale[controlOpts.horiz] - Math.round( ( dimensions.w - ui.position.left ) / dimensions.w * self._scale[controlOpts.horiz] );\n\n\t\t\tself._color[controlOpts.horiz]( horizVal )[controlOpts.vert]( vertVal );\n\n\t\t\tself.active = 'square';\n\t\t\tself._change.apply( self, arguments );\n\t\t},\n\n\t\t_setOption: function( key, value ) {\n\t\t\tvar self = this,\n\t\t\t\toldValue = self.options[key],\n\t\t\t\tdoDimensions = false,\n\t\t\t\thexLessColor,\n\t\t\t\tnewColor,\n\t\t\t\tmethod;\n\n\t\t\t// ensure the new value is set. We can reset to oldValue if some check wasn't met.\n\t\t\tself.options[key] = value;\n\n\t\t\tswitch(key) {\n\t\t\t\tcase 'color':\n\t\t\t\t\t// cast to string in case we have a number\n\t\t\t\t\tvalue = '' + value;\n\t\t\t\t\thexLessColor = value.replace( /^#/, '' );\n\t\t\t\t\tnewColor = new Color( value ).setHSpace( self.options.mode );\n\t\t\t\t\tif ( newColor.error ) {\n\t\t\t\t\t\tself.options[key] = oldValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._color = newColor;\n\t\t\t\t\t\tself.options.color = self.options[key] = self._color.toString();\n\t\t\t\t\t\tself.active = 'external';\n\t\t\t\t\t\tself._change();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'palettes':\n\t\t\t\t\tdoDimensions = true;\n\n\t\t\t\t\tif ( value ) {\n\t\t\t\t\t\tself._addPalettes();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.picker.find('.iris-palette-container').remove();\n\t\t\t\t\t}\n\n\t\t\t\t\t// do we need to add events?\n\t\t\t\t\tif ( ! oldValue ) {\n\t\t\t\t\t\tself._paletteListeners();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'width':\n\t\t\t\t\tdoDimensions = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'border':\n\t\t\t\t\tdoDimensions = true;\n\t\t\t\t\tmethod = value ? 'addClass' : 'removeClass';\n\t\t\t\t\tself.picker[method]('iris-border');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mode':\n\t\t\t\tcase 'controls':\n\t\t\t\t\t// if nothing's changed, let's bail, since this causes re-rendering the whole widget\n\t\t\t\t\tif ( oldValue === value ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we're using these poorly named variables because they're already scoped.\n\t\t\t\t\t// method is the element that Iris was called on. oldValue will be the options\n\t\t\t\t\tmethod = self.element;\n\t\t\t\t\toldValue = self.options;\n\t\t\t\t\toldValue.hide = ! self.picker.is( ':visible' );\n\t\t\t\t\tself.destroy();\n\t\t\t\t\tself.picker.remove();\n\t\t\t\t\treturn $(self.element).iris(oldValue);\n\t\t\t}\n\n\t\t\t// Do we need to recalc dimensions?\n\t\t\tif ( doDimensions ) {\n\t\t\t\tself._dimensions(true);\n\t\t\t}\n\t\t},\n\n\t\t_squareDimensions: function( forceRefresh ) {\n\t\t\tvar square = this.controls.square,\n\t\t\t\tdimensions,\n\t\t\t\tcontrol;\n\n\t\t\tif ( forceRefresh !== undef && square.data('dimensions') ) {\n\t\t\t\treturn square.data('dimensions');\n\t\t\t}\n\n\t\t\tcontrol = this.controls.squareDrag;\n\t\t\tdimensions = {\n\t\t\t\tw: square.width(),\n\t\t\t\th: square.height()\n\t\t\t};\n\t\t\tsquare.data( 'dimensions', dimensions );\n\t\t\treturn dimensions;\n\t\t},\n\n\t\t_isNonHueControl: function( active, type ) {\n\t\t\tif ( active === 'square' && this.options.controls.strip === 'h' ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( type === 'external' || ( type === 'h' && active === 'strip' ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t_change: function() {\n\t\t\tvar self = this,\n\t\t\t\tcontrols = self.controls,\n\t\t\t\tcolor = self._getHSpaceColor(),\n\t\t\t\tactions = [ 'square', 'strip' ],\n\t\t\t\tcontrolOpts = self.options.controls,\n\t\t\t\ttype = controlOpts[self.active] || 'external',\n\t\t\t\toldHue = self.hue;\n\n\t\t\tif ( self.active === 'strip' ) {\n\t\t\t\t// take no action on any of the square sliders if we adjusted the strip\n\t\t\t\tactions = [];\n\t\t\t} else if ( self.active !== 'external' ) {\n\t\t\t\t// for non-strip, non-external, strip should never change\n\t\t\t\tactions.pop(); // conveniently the last item\n\t\t\t}\n\n\t\t\t$.each( actions, function(index, item) {\n\t\t\t\tvar value, dimensions, cssObj;\n\t\t\t\tif ( item !== self.active ) {\n\t\t\t\t\tswitch ( item ) {\n\t\t\t\t\t\tcase 'strip':\n\t\t\t\t\t\t\t// reverse for hue\n\t\t\t\t\t\t\tvalue = ( controlOpts.strip === 'h' ) ? self._scale[controlOpts.strip] - color[controlOpts.strip] : color[controlOpts.strip];\n\t\t\t\t\t\t\tcontrols.stripSlider.slider( 'value', value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'square':\n\t\t\t\t\t\t\tdimensions = self._squareDimensions();\n\t\t\t\t\t\t\tcssObj = {\n\t\t\t\t\t\t\t\tleft: color[controlOpts.horiz] / self._scale[controlOpts.horiz] * dimensions.w,\n\t\t\t\t\t\t\t\ttop: dimensions.h - ( color[controlOpts.vert] / self._scale[controlOpts.vert] * dimensions.h )\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tself.controls.squareDrag.css( cssObj );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Ensure that we don't change hue if we triggered a hue reset\n\t\t\tif ( color.h !== oldHue && self._isNonHueControl( self.active, type ) ) {\n\t\t\t\tself._color.h(oldHue);\n\t\t\t}\n\n\t\t\t// store hue for repeating above check next time\n\t\t\tself.hue = self._color.h();\n\n\t\t\tself.options.color = self._color.toString();\n\n\t\t\t// only run after the first time\n\t\t\tif ( self._inited ) {\n\t\t\t\tself._trigger( 'change', { type: self.active }, { color: self._color } );\n\t\t\t}\n\n\t\t\tif ( self.element.is( ':input' ) && ! self._color.error ) {\n\t\t\t\tself.element.removeClass( 'iris-error' );\n\t\t\t\tif ( self.element.val() !== self._color.toString() ) {\n\t\t\t\t\tself.element.val( self._color.toString() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tself._paint();\n\t\t\tself._inited = true;\n\t\t\tself.active = false;\n\t\t},\n\t\t// taken from underscore.js _.debounce method\n\t\t_debounce: function( func, wait, immediate ) {\n\t\t\tvar timeout, result;\n\t\t\treturn function() {\n\t\t\t\tvar context = this,\n\t\t\t\t\targs = arguments,\n\t\t\t\t\tlater,\n\t\t\t\t\tcallNow;\n\n\t\t\t\tlater = function() {\n\t\t\t\t\ttimeout = null;\n\t\t\t\t\tif ( ! immediate) {\n\t\t\t\t\t\tresult = func.apply( context, args );\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tcallNow = immediate && !timeout;\n\t\t\t\tclearTimeout( timeout );\n\t\t\t\ttimeout = setTimeout( later, wait );\n\t\t\t\tif ( callNow ) {\n\t\t\t\t\tresult = func.apply( context, args );\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t},\n\t\tshow: function() {\n\t\t\tthis.picker.show();\n\t\t},\n\t\thide: function() {\n\t\t\tthis.picker.hide();\n\t\t},\n\t\ttoggle: function() {\n\t\t\tthis.picker.toggle();\n\t\t},\n\t\tcolor: function(newColor) {\n\t\t\tif ( newColor === true ) {\n\t\t\t\treturn this._color.clone();\n\t\t\t} else if ( newColor === undef ) {\n\t\t\t\treturn this._color.toString();\n\t\t\t}\n\t\t\tthis.option('color', newColor);\n\t\t}\n\t};\n\t// initialize the widget\n\t$.widget( 'a8c.iris', Iris );\n\t// add CSS\n\t$( '<style id=\"iris-css\">' + _css + '</style>' ).appendTo( 'head' );\n\n}( jQuery ));\n/*! Color.js - v0.9.11 - 2013-08-09\n* https://github.com/Automattic/Color.js\n* Copyright (c) 2013 Matt Wiebe; Licensed GPLv2 */\n(function(global, undef) {\n\n\tvar Color = function( color, type ) {\n\t\tif ( ! ( this instanceof Color ) )\n\t\t\treturn new Color( color, type );\n\n\t\treturn this._init( color, type );\n\t};\n\n\tColor.fn = Color.prototype = {\n\t\t_color: 0,\n\t\t_alpha: 1,\n\t\terror: false,\n\t\t// for preserving hue/sat in fromHsl().toHsl() flows\n\t\t_hsl: { h: 0, s: 0, l: 0 },\n\t\t// for preserving hue/sat in fromHsv().toHsv() flows\n\t\t_hsv: { h: 0, s: 0, v: 0 },\n\t\t// for setting hsl or hsv space - needed for .h() & .s() functions to function properly\n\t\t_hSpace: 'hsl',\n\t\t_init: function( color ) {\n\t\t\tvar func = 'noop';\n\t\t\tswitch ( typeof color ) {\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t// alpha?\n\t\t\t\t\t\tif ( color.a !== undef )\n\t\t\t\t\t\t\tthis.a( color.a );\n\t\t\t\t\t\tfunc = ( color.r !== undef ) ? 'fromRgb' :\n\t\t\t\t\t\t\t( color.l !== undef ) ? 'fromHsl' :\n\t\t\t\t\t\t\t( color.v !== undef ) ? 'fromHsv' : func;\n\t\t\t\t\t\treturn this[func]( color );\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\treturn this.fromCSS( color );\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\treturn this.fromInt( parseInt( color, 10 ) );\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_error: function() {\n\t\t\tthis.error = true;\n\t\t\treturn this;\n\t\t},\n\n\t\tclone: function() {\n\t\t\tvar newColor = new Color( this.toInt() ),\n\t\t\t\tcopy = ['_alpha', '_hSpace', '_hsl', '_hsv', 'error'];\n\t\t\tfor ( var i = copy.length - 1; i >= 0; i-- ) {\n\t\t\t\tnewColor[ copy[i] ] = this[ copy[i] ];\n\t\t\t}\n\t\t\treturn newColor;\n\t\t},\n\n\t\tsetHSpace: function( space ) {\n\t\t\tthis._hSpace = ( space === 'hsv' ) ? space : 'hsl';\n\t\t\treturn this;\n\t\t},\n\n\t\tnoop: function() {\n\t\t\treturn this;\n\t\t},\n\n\t\tfromCSS: function( color ) {\n\t\t\tvar list,\n\t\t\t\tleadingRE = /^(rgb|hs(l|v))a?\\(/;\n\t\t\tthis.error = false;\n\n\t\t\t// whitespace and semicolon trim\n\t\t\tcolor = color.replace(/^\\s+/, '').replace(/\\s+$/, '').replace(/;$/, '');\n\n\t\t\tif ( color.match(leadingRE) && color.match(/\\)$/) ) {\n\t\t\t\tlist = color.replace(/(\\s|%)/g, '').replace(leadingRE, '').replace(/,?\\);?$/, '').split(',');\n\n\t\t\t\tif ( list.length < 3 )\n\t\t\t\t\treturn this._error();\n\n\t\t\t\tif ( list.length === 4 ) {\n\t\t\t\t\tthis.a( parseFloat( list.pop() ) );\n\t\t\t\t\t// error state has been set to true in .a() if we passed NaN\n\t\t\t\t\tif ( this.error )\n\t\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = list.length - 1; i >= 0; i--) {\n\t\t\t\t\tlist[i] = parseInt(list[i], 10);\n\t\t\t\t\tif ( isNaN( list[i] ) )\n\t\t\t\t\t\treturn this._error();\n\t\t\t\t}\n\n\t\t\t\tif ( color.match(/^rgb/) ) {\n\t\t\t\t\treturn this.fromRgb( {\n\t\t\t\t\t\tr: list[0],\n\t\t\t\t\t\tg: list[1],\n\t\t\t\t\t\tb: list[2]\n\t\t\t\t\t} );\n\t\t\t\t} else if ( color.match(/^hsv/) ) {\n\t\t\t\t\treturn this.fromHsv( {\n\t\t\t\t\t\th: list[0],\n\t\t\t\t\t\ts: list[1],\n\t\t\t\t\t\tv: list[2]\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.fromHsl( {\n\t\t\t\t\t\th: list[0],\n\t\t\t\t\t\ts: list[1],\n\t\t\t\t\t\tl: list[2]\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// must be hex amirite?\n\t\t\t\treturn this.fromHex( color );\n\t\t\t}\n\t\t},\n\n\t\tfromRgb: function( rgb, preserve ) {\n\t\t\tif ( typeof rgb !== 'object' || rgb.r === undef || rgb.g === undef || rgb.b === undef )\n\t\t\t\treturn this._error();\n\n\t\t\tthis.error = false;\n\t\t\treturn this.fromInt( parseInt( ( rgb.r << 16 ) + ( rgb.g << 8 ) + rgb.b, 10 ), preserve );\n\t\t},\n\n\t\tfromHex: function( color ) {\n\t\t\tcolor = color.replace(/^#/, '').replace(/^0x/, '');\n\t\t\tif ( color.length === 3 ) {\n\t\t\t\tcolor = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];\n\t\t\t}\n\n\t\t\t// rough error checking - this is where things go squirrely the most\n\t\t\tthis.error = ! /^[0-9A-F]{6}$/i.test( color );\n\t\t\treturn this.fromInt( parseInt( color, 16 ) );\n\t\t},\n\n\t\tfromHsl: function( hsl ) {\n\t\t\tvar r, g, b, q, p, h, s, l;\n\n\t\t\tif ( typeof hsl !== 'object' || hsl.h === undef || hsl.s === undef || hsl.l === undef )\n\t\t\t\treturn this._error();\n\n\t\t\tthis._hsl = hsl; // store it\n\t\t\tthis._hSpace = 'hsl'; // implicit\n\t\t\th = hsl.h / 360; s = hsl.s / 100; l = hsl.l / 100;\n\t\t\tif ( s === 0 ) {\n\t\t\t\tr = g = b = l; // achromatic\n\t\t\t}\n\t\t\telse {\n\t\t\t\tq = l < 0.5 ? l * ( 1 + s ) : l + s - l * s;\n\t\t\t\tp = 2 * l - q;\n\t\t\t\tr = this.hue2rgb( p, q, h + 1/3 );\n\t\t\t\tg = this.hue2rgb( p, q, h );\n\t\t\t\tb = this.hue2rgb( p, q, h - 1/3 );\n\t\t\t}\n\t\t\treturn this.fromRgb( {\n\t\t\t\tr: r * 255,\n\t\t\t\tg: g * 255,\n\t\t\t\tb: b * 255\n\t\t\t}, true ); // true preserves hue/sat\n\t\t},\n\n\t\tfromHsv: function( hsv ) {\n\t\t\tvar h, s, v, r, g, b, i, f, p, q, t;\n\t\t\tif ( typeof hsv !== 'object' || hsv.h === undef || hsv.s === undef || hsv.v === undef )\n\t\t\t\treturn this._error();\n\n\t\t\tthis._hsv = hsv; // store it\n\t\t\tthis._hSpace = 'hsv'; // implicit\n\n\t\t\th = hsv.h / 360; s = hsv.s / 100; v = hsv.v / 100;\n\t\t\ti = Math.floor( h * 6 );\n\t\t\tf = h * 6 - i;\n\t\t\tp = v * ( 1 - s );\n\t\t\tq = v * ( 1 - f * s );\n\t\t\tt = v * ( 1 - ( 1 - f ) * s );\n\n\t\t\tswitch( i % 6 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tr = v; g = t; b = p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tr = q; g = v; b = p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tr = p; g = v; b = t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tr = p; g = q; b = v;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tr = t; g = p; b = v;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tr = v; g = p; b = q;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn this.fromRgb( {\n\t\t\t\tr: r * 255,\n\t\t\t\tg: g * 255,\n\t\t\t\tb: b * 255\n\t\t\t}, true ); // true preserves hue/sat\n\n\t\t},\n\t\t// everything comes down to fromInt\n\t\tfromInt: function( color, preserve ) {\n\t\t\tthis._color = parseInt( color, 10 );\n\n\t\t\tif ( isNaN( this._color ) )\n\t\t\t\tthis._color = 0;\n\n\t\t\t// let's coerce things\n\t\t\tif ( this._color > 16777215 )\n\t\t\t\tthis._color = 16777215;\n\t\t\telse if ( this._color < 0 )\n\t\t\t\tthis._color = 0;\n\n\t\t\t// let's not do weird things\n\t\t\tif ( preserve === undef ) {\n\t\t\t\tthis._hsv.h = this._hsv.s = this._hsl.h = this._hsl.s = 0;\n\t\t\t}\n\t\t\t// EVENT GOES HERE\n\t\t\treturn this;\n\t\t},\n\n\t\thue2rgb: function( p, q, t ) {\n\t\t\tif ( t < 0 ) {\n\t\t\t\tt += 1;\n\t\t\t}\n\t\t\tif ( t > 1 ) {\n\t\t\t\tt -= 1;\n\t\t\t}\n\t\t\tif ( t < 1/6 ) {\n\t\t\t\treturn p + ( q - p ) * 6 * t;\n\t\t\t}\n\t\t\tif ( t < 1/2 ) {\n\t\t\t\treturn q;\n\t\t\t}\n\t\t\tif ( t < 2/3 ) {\n\t\t\t\treturn p + ( q - p ) * ( 2/3 - t ) * 6;\n\t\t\t}\n\t\t\treturn p;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\tvar hex = parseInt( this._color, 10 ).toString( 16 );\n\t\t\tif ( this.error )\n\t\t\t\treturn '';\n\t\t\t// maybe left pad it\n\t\t\tif ( hex.length < 6 ) {\n\t\t\t\tfor (var i = 6 - hex.length - 1; i >= 0; i--) {\n\t\t\t\t\thex = '0' + hex;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn '#' + hex;\n\t\t},\n\n\t\ttoCSS: function( type, alpha ) {\n\t\t\ttype = type || 'hex';\n\t\t\talpha = parseFloat( alpha || this._alpha );\n\t\t\tswitch ( type ) {\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\t\t\t\t\tvar rgb = this.toRgb();\n\t\t\t\t\tif ( alpha < 1 ) {\n\t\t\t\t\t\treturn \"rgba( \" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + alpha + \" )\";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn \"rgb( \" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \" )\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\t\t\t\t\tvar hsl = this.toHsl();\n\t\t\t\t\tif ( alpha < 1 ) {\n\t\t\t\t\t\treturn \"hsla( \" + hsl.h + \", \" + hsl.s + \"%, \" + hsl.l + \"%, \" + alpha + \" )\";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn \"hsl( \" + hsl.h + \", \" + hsl.s + \"%, \" + hsl.l + \"% )\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn this.toString();\n\t\t\t}\n\t\t},\n\n\t\ttoRgb: function() {\n\t\t\treturn {\n\t\t\t\tr: 255 & ( this._color >> 16 ),\n\t\t\t\tg: 255 & ( this._color >> 8 ),\n\t\t\t\tb: 255 & ( this._color )\n\t\t\t};\n\t\t},\n\n\t\ttoHsl: function() {\n\t\t\tvar rgb = this.toRgb();\n\t\t\tvar r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255;\n\t\t\tvar max = Math.max( r, g, b ), min = Math.min( r, g, b );\n\t\t\tvar h, s, l = ( max + min ) / 2;\n\n\t\t\tif ( max === min ) {\n\t\t\t\th = s = 0; // achromatic\n\t\t\t} else {\n\t\t\t\tvar d = max - min;\n\t\t\t\ts = l > 0.5 ? d / ( 2 - max - min ) : d / ( max + min );\n\t\t\t\tswitch ( max ) {\n\t\t\t\t\tcase r: h = ( g - b ) / d + ( g < b ? 6 : 0 );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase g: h = ( b - r ) / d + 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase b: h = ( r - g ) / d + 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\th /= 6;\n\t\t\t}\n\n\t\t\t// maintain hue & sat if we've been manipulating things in the HSL space.\n\t\t\th = Math.round( h * 360 );\n\t\t\tif ( h === 0 && this._hsl.h !== h ) {\n\t\t\t\th = this._hsl.h;\n\t\t\t}\n\t\t\ts = Math.round( s * 100 );\n\t\t\tif ( s === 0 && this._hsl.s ) {\n\t\t\t\ts = this._hsl.s;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\th: h,\n\t\t\t\ts: s,\n\t\t\t\tl: Math.round( l * 100 )\n\t\t\t};\n\n\t\t},\n\n\t\ttoHsv: function() {\n\t\t\tvar rgb = this.toRgb();\n\t\t\tvar r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255;\n\t\t\tvar max = Math.max( r, g, b ), min = Math.min( r, g, b );\n\t\t\tvar h, s, v = max;\n\t\t\tvar d = max - min;\n\t\t\ts = max === 0 ? 0 : d / max;\n\n\t\t\tif ( max === min ) {\n\t\t\t\th = s = 0; // achromatic\n\t\t\t} else {\n\t\t\t\tswitch( max ){\n\t\t\t\t\tcase r:\n\t\t\t\t\t\th = ( g - b ) / d + ( g < b ? 6 : 0 );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase g:\n\t\t\t\t\t\th = ( b - r ) / d + 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase b:\n\t\t\t\t\t\th = ( r - g ) / d + 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\th /= 6;\n\t\t\t}\n\n\t\t\t// maintain hue & sat if we've been manipulating things in the HSV space.\n\t\t\th = Math.round( h * 360 );\n\t\t\tif ( h === 0 && this._hsv.h !== h ) {\n\t\t\t\th = this._hsv.h;\n\t\t\t}\n\t\t\ts = Math.round( s * 100 );\n\t\t\tif ( s === 0 && this._hsv.s ) {\n\t\t\t\ts = this._hsv.s;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\th: h,\n\t\t\t\ts: s,\n\t\t\t\tv: Math.round( v * 100 )\n\t\t\t};\n\t\t},\n\n\t\ttoInt: function() {\n\t\t\treturn this._color;\n\t\t},\n\n\t\ttoIEOctoHex: function() {\n\t\t\t// AARRBBGG\n\t\t\tvar hex = this.toString();\n\t\t\tvar AA = parseInt( 255 * this._alpha, 10 ).toString(16);\n\t\t\tif ( AA.length === 1 ) {\n\t\t\t\tAA = '0' + AA;\n\t\t\t}\n\t\t\treturn '#' + AA + hex.replace(/^#/, '' );\n\t\t},\n\n\t\ttoLuminosity: function() {\n\t\t\tvar rgb = this.toRgb();\n\t\t\treturn 0.2126 * Math.pow( rgb.r / 255, 2.2 ) + 0.7152 * Math.pow( rgb.g / 255, 2.2 ) + 0.0722 * Math.pow( rgb.b / 255, 2.2);\n\t\t},\n\n\t\tgetDistanceLuminosityFrom: function( color ) {\n\t\t\tif ( ! ( color instanceof Color ) ) {\n\t\t\t\tthrow 'getDistanceLuminosityFrom requires a Color object';\n\t\t\t}\n\t\t\tvar lum1 = this.toLuminosity();\n\t\t\tvar lum2 = color.toLuminosity();\n\t\t\tif ( lum1 > lum2 ) {\n\t\t\t\treturn ( lum1 + 0.05 ) / ( lum2 + 0.05 );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ( lum2 + 0.05 ) / ( lum1 + 0.05 );\n\t\t\t}\n\t\t},\n\n\t\tgetMaxContrastColor: function() {\n\t\t\tvar lum = this.toLuminosity();\n\t\t\tvar hex = ( lum >= 0.5 ) ? '000000' : 'ffffff';\n\t\t\treturn new Color( hex );\n\t\t},\n\n\t\tgetReadableContrastingColor: function( bgColor, minContrast ) {\n\t\t\tif ( ! bgColor instanceof Color ) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// you shouldn't use less than 5, but you might want to.\n\t\t\tvar targetContrast = ( minContrast === undef ) ? 5 : minContrast;\n\t\t\t// working things\n\t\t\tvar contrast = bgColor.getDistanceLuminosityFrom( this );\n\t\t\tvar maxContrastColor = bgColor.getMaxContrastColor();\n\t\t\tvar maxContrast = maxContrastColor.getDistanceLuminosityFrom( bgColor );\n\n\t\t\t// if current max contrast is less than the target contrast, we had wishful thinking.\n\t\t\t// still, go max\n\t\t\tif ( maxContrast <= targetContrast ) {\n\t\t\t\treturn maxContrastColor;\n\t\t\t}\n\t\t\t// or, we might already have sufficient contrast\n\t\t\telse if ( contrast >= targetContrast ) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar incr = ( 0 === maxContrastColor.toInt() ) ? -1 : 1;\n\t\t\twhile ( contrast < targetContrast ) {\n\t\t\t\tthis.l( incr, true ); // 2nd arg turns this into an incrementer\n\t\t\t\tcontrast = this.getDistanceLuminosityFrom( bgColor );\n\t\t\t\t// infininite loop prevention: you never know.\n\t\t\t\tif ( this._color === 0 || this._color === 16777215 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ta: function( val ) {\n\t\t\tif ( val === undef )\n\t\t\t\treturn this._alpha;\n\n\t\t\tvar a = parseFloat( val );\n\n\t\t\tif ( isNaN( a ) )\n\t\t\t\treturn this._error();\n\n\t\t\tthis._alpha = a;\n\t\t\treturn this;\n\t\t},\n\n\t\t// TRANSFORMS\n\n\t\tdarken: function( amount ) {\n\t\t\tamount = amount || 5;\n\t\t\treturn this.l( - amount, true );\n\t\t},\n\n\t\tlighten: function( amount ) {\n\t\t\tamount = amount || 5;\n\t\t\treturn this.l( amount, true );\n\t\t},\n\n\t\tsaturate: function( amount ) {\n\t\t\tamount = amount || 15;\n\t\t\treturn this.s( amount, true );\n\t\t},\n\n\t\tdesaturate: function( amount ) {\n\t\t\tamount = amount || 15;\n\t\t\treturn this.s( - amount, true );\n\t\t},\n\n\t\ttoGrayscale: function() {\n\t\t\treturn this.setHSpace('hsl').s( 0 );\n\t\t},\n\n\t\tgetComplement: function() {\n\t\t\treturn this.h( 180, true );\n\t\t},\n\n\t\tgetSplitComplement: function( step ) {\n\t\t\tstep = step || 1;\n\t\t\tvar incr = 180 + ( step * 30 );\n\t\t\treturn this.h( incr, true );\n\t\t},\n\n\t\tgetAnalog: function( step ) {\n\t\t\tstep = step || 1;\n\t\t\tvar incr = step * 30;\n\t\t\treturn this.h( incr, true );\n\t\t},\n\n\t\tgetTetrad: function( step ) {\n\t\t\tstep = step || 1;\n\t\t\tvar incr = step * 60;\n\t\t\treturn this.h( incr, true );\n\t\t},\n\n\t\tgetTriad: function( step ) {\n\t\t\tstep = step || 1;\n\t\t\tvar incr = step * 120;\n\t\t\treturn this.h( incr, true );\n\t\t},\n\n\t\t_partial: function( key ) {\n\t\t\tvar prop = shortProps[key];\n\t\t\treturn function( val, incr ) {\n\t\t\t\tvar color = this._spaceFunc('to', prop.space);\n\n\t\t\t\t// GETTER\n\t\t\t\tif ( val === undef )\n\t\t\t\t\treturn color[key];\n\n\t\t\t\t// INCREMENT\n\t\t\t\tif ( incr === true )\n\t\t\t\t\tval = color[key] + val;\n\n\t\t\t\t// MOD & RANGE\n\t\t\t\tif ( prop.mod )\n\t\t\t\t\tval = val % prop.mod;\n\t\t\t\tif ( prop.range )\n\t\t\t\t\tval = ( val < prop.range[0] ) ? prop.range[0] : ( val > prop.range[1] ) ? prop.range[1] : val;\n\n\t\t\t\t// NEW VALUE\n\t\t\t\tcolor[key] = val;\n\n\t\t\t\treturn this._spaceFunc('from', prop.space, color);\n\t\t\t};\n\t\t},\n\n\t\t_spaceFunc: function( dir, s, val ) {\n\t\t\tvar space = s || this._hSpace,\n\t\t\t\tfuncName = dir + space.charAt(0).toUpperCase() + space.substr(1);\n\t\t\treturn this[funcName](val);\n\t\t}\n\t};\n\n\tvar shortProps = {\n\t\th: {\n\t\t\tmod: 360\n\t\t},\n\t\ts: {\n\t\t\trange: [0,100]\n\t\t},\n\t\tl: {\n\t\t\tspace: 'hsl',\n\t\t\trange: [0,100]\n\t\t},\n\t\tv: {\n\t\t\tspace: 'hsv',\n\t\t\trange: [0,100]\n\t\t},\n\t\tr: {\n\t\t\tspace: 'rgb',\n\t\t\trange: [0,255]\n\t\t},\n\t\tg: {\n\t\t\tspace: 'rgb',\n\t\t\trange: [0,255]\n\t\t},\n\t\tb: {\n\t\t\tspace: 'rgb',\n\t\t\trange: [0,255]\n\t\t}\n\t};\n\n\tfor ( var key in shortProps ) {\n\t\tif ( shortProps.hasOwnProperty( key ) )\n\t\t\tColor.fn[key] = Color.fn._partial(key);\n\t}\n\n\t// play nicely with Node + browser\n\tif ( typeof exports === 'object' )\n\t\tmodule.exports = Color;\n\telse\n\t\tglobal.Color = Color;\n\n}(this));\n"],"sourceRoot":"assets/scripts/"}